Jasne, oto kompleksowy plan dla agenta kodujÄ…cego oraz treÅ›Ä‡ merytoryczna do moduÅ‚u "Baza Wiedzy".

-----

## ğŸš€ Plan dla Agenta: Budowa ModuÅ‚u Regresji

Oto szczegÃ³Å‚owy plan krok po kroku, jak zaimplementowaÄ‡ moduÅ‚ analizy regresji w aplikacji Streamlit.

**Cel:** Stworzenie nowej "strony" (moduÅ‚u) w aplikacji, ktÃ³ra pozwala uÅ¼ytkownikowi na wgranie danych (lub uÅ¼ycie demo), wybranie zmiennych, a nastÄ™pnie przeprowadzenie i porÃ³wnanie regresji liniowej i logarytmicznej.

### 1\. Struktura Pliku i Importy

Zalecam utworzenie nowego pliku, np. `regression_module.py`.

**Wymagane biblioteki:**

```python
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error
import plotly.express as px
import plotly.graph_objects as go
```

### 2\. GÅ‚Ã³wna Funkcja ModuÅ‚u

StwÃ³rz gÅ‚Ã³wnÄ… funkcjÄ™, ktÃ³ra bÄ™dzie wywoÅ‚ywana przez gÅ‚Ã³wnÄ… nawigacjÄ™ aplikacji.

```python
def run_regression_module():
    st.title("ğŸ“ˆ ModuÅ‚ Analizy Regresji")
    st.markdown("Analizuj i porÃ³wnuj modele regresji liniowej i logarytmicznej.")
    
    # Krok 1: Wprowadzenie Danych
    # Krok 2: WybÃ³r Zmiennych
    # Krok 3: Analiza i Wizualizacja
```

### 3\. Krok 1: Wprowadzenie Danych (z Demo)

UÅ¼yj `st.sidebar` lub `st.tabs` do wyboru ÅºrÃ³dÅ‚a danych.

```python
    # === SEKCJA 1: Å¹RÃ“DÅO DANYCH ===
    st.sidebar.header("1. WprowadÅº Dane")
    data_source = st.sidebar.radio(
        "Wybierz ÅºrÃ³dÅ‚o danych:",
        ("UÅ¼yj danych demo", "WprowadÅº wÅ‚asne dane")
    )
    
    df = None # Inicjalizacja DataFrame

    # --- Dane Demo ---
    def get_demo_data_linear():
        X = np.linspace(1, 50, 100)
        y = 2.5 * X + 4 + np.random.randn(100) * 8 # Silna korelacja liniowa + szum
        return pd.DataFrame({'X_lin': X, 'Y_lin': y})

    def get_demo_data_log():
        X = np.linspace(1, 50, 100)
        y = 3 * np.log(X) + 2 + np.random.randn(100) * 0.5 # Korelacja logarytmiczna + szum
        return pd.DataFrame({'X_log': X, 'Y_log': y})

    if data_source == "UÅ¼yj danych demo":
        demo_type = st.sidebar.selectbox("Wybierz typ danych demo:", ["Dane Liniowe", "Dane Logarytmiczne"])
        if demo_type == "Dane Liniowe":
            df = get_demo_data_linear()
        else:
            df = get_demo_data_log()

    # --- WÅ‚asne Dane ---
    else:
        uploaded_file = st.sidebar.file_uploader("Wgraj plik CSV lub Excel", type=["csv", "xlsx"])
        if uploaded_file:
            try:
                if uploaded_file.name.endswith('.csv'):
                    df = pd.read_csv(uploaded_file)
                else:
                    df = pd.read_excel(uploaded_file)
            except Exception as e:
                st.error(f"BÅ‚Ä…d podczas wczytywania pliku: {e}")

    # JeÅ›li dane nie sÄ… wczytane, zakoÅ„cz dziaÅ‚anie moduÅ‚u w tym miejscu
    if df is None or df.empty:
        st.info("ProszÄ™ wczytaÄ‡ dane lub wybraÄ‡ zestaw demo, aby rozpoczÄ…Ä‡ analizÄ™.")
        st.stop()

    st.subheader("PodglÄ…d Danych")
    st.dataframe(df.head())
```

### 4\. Krok 2: WybÃ³r Zmiennych

PozwÃ³l uÅ¼ytkownikowi wybraÄ‡, ktÃ³re kolumny to X i Y.

```python
    # === SEKCJA 2: WYBÃ“R ZMIENNYCH ===
    st.sidebar.header("2. Konfiguracja Modelu")
    
    # Wybierz tylko kolumny numeryczne
    numeric_cols = df.select_dtypes(include=np.number).columns.tolist()
    
    if len(numeric_cols) < 2:
        st.warning("Twoje dane muszÄ… zawieraÄ‡ co najmniej dwie kolumny numeryczne.")
        st.stop()

    col_x = st.sidebar.selectbox("Wybierz zmiennÄ… niezaleÅ¼nÄ… (X):", numeric_cols)
    # UsuÅ„ wybranÄ… kolumnÄ™ X z listy dostÄ™pnych dla Y
    available_y_cols = [col for col in numeric_cols if col != col_x]
    col_y = st.sidebar.selectbox("Wybierz zmiennÄ… zaleÅ¼nÄ… (Y):", available_y_cols)
```

### 5\. Krok 3: Analiza i Wizualizacja

To jest rdzeÅ„ moduÅ‚u. PrzeprowadÅº obliczenia i wyÅ›wietl wyniki.

```python
    # === SEKCJA 3: ANALIZA I WYNIKI ===
    
    # Przygotowanie danych (usuwanie brakÃ³w danych)
    analysis_df = df[[col_x, col_y]].dropna()
    X_raw = analysis_df[[col_x]]
    y = analysis_df[col_y]

    if X_raw.empty or y.empty:
        st.error("Wybrane kolumny nie zawierajÄ… danych po usuniÄ™ciu brakÃ³w (NaN).")
        st.stop()

    st.header("Wyniki Analizy Regresji")
    
    # UÅ¼yj kolumn do prezentacji wynikÃ³w
    col1, col2 = st.columns(2)

    # --- Model Liniowy ---
    with col1:
        st.subheader("Model Liniowy")
        st.markdown("`y = a * x + b`")
        
        model_lin = LinearRegression()
        model_lin.fit(X_raw, y)
        y_pred_lin = model_lin.predict(X_raw)
        
        a_lin = model_lin.coef_[0]
        b_lin = model_lin.intercept_
        r2_lin = r2_score(y, y_pred_lin)
        mse_lin = mean_squared_error(y, y_pred_lin)
        
        st.metric("R-kwadrat (RÂ²)", f"{r2_lin:.4f}")
        st.metric("BÅ‚Ä…d Åšredniokw. (MSE)", f"{mse_lin:.4f}")
        st.write(f"**WzÃ³r:** `y = {a_lin:.3f} * x + {b_lin:.3f}`")

    # --- Model Logarytmiczny ---
    with col2:
        st.subheader("Model Logarytmiczny")
        st.markdown("`y = a * ln(x) + b`")

        # Model logarytmiczny wymaga X > 0
        log_df = analysis_df[analysis_df[col_x] > 0]
        if log_df.empty:
            st.warning("Model logarytmiczny wymaga wartoÅ›ci X > 0. Brak danych do analizy.")
            r2_log, mse_log, a_log, b_log = (np.nan,)*4 # Ustaw jako NaN
        else:
            X_log_transformed = np.log(log_df[[col_x]]) # Transformacja X -> ln(X)
            y_log_target = log_df[col_y]
            
            model_log = LinearRegression()
            model_log.fit(X_log_transformed, y_log_target)
            y_pred_log = model_log.predict(X_log_transformed)
            
            a_log = model_log.coef_[0]
            b_log = model_log.intercept_
            r2_log = r2_score(y_log_target, y_pred_log)
            mse_log = mean_squared_error(y_log_target, y_pred_log)

            st.metric("R-kwadrat (RÂ²)", f"{r2_log:.4f}")
            st.metric("BÅ‚Ä…d Åšredniokw. (MSE)", f"{mse_log:.4f}")
            st.write(f"**WzÃ³r:** `y = {a_log:.3f} * ln(x) + {b_log:.3f}`")
            st.caption(f"Analiza przeprowadzona na {len(log_df)} wierszach (gdzie {col_x} > 0).")

    # --- Wizualizacja ---
    st.subheader("Wizualizacja Dopasowania")
    
    # StwÃ³rz wykres punktowy
    fig = px.scatter(analysis_df, x=col_x, y=col_y, title="Dopasowanie Modeli Regresji", labels={col_x: f"X: {col_x}", col_y: f"Y: {col_y}"})
    
    # Dodaj liniÄ™ regresji liniowej
    fig.add_trace(go.Scatter(x=X_raw[col_x], y=y_pred_lin, mode='lines', name=f"Liniowa (RÂ²={r2_lin:.3f})", line=dict(color='red', width=3)))
    
    # Dodaj liniÄ™ regresji logarytmicznej (jeÅ›li obliczona)
    if not np.isnan(r2_log):
        # Sortuj wartoÅ›ci dla gÅ‚adkiej linii
        log_df_sorted = log_df.sort_values(by=col_x)
        X_log_plot = np.log(log_df_sorted[[col_x]])
        y_pred_log_plot = model_log.predict(X_log_plot)
        
        fig.add_trace(go.Scatter(x=log_df_sorted[col_x], y=y_pred_log_plot, mode='lines', name=f"Logarytm. (RÂ²={r2_log:.3f})", line=dict(color='green', width=3)))

    st.plotly_chart(fig, use_container_width=True)

    # === SEKCJA 4: INTERPRETACJA I OVERFITTING ===
    st.header("WybÃ³r Modelu i Interpretacja")

    # PorÃ³wnanie
    if np.isnan(r2_log) and not np.isnan(r2_lin):
        st.info("Tylko model liniowy mÃ³gÅ‚ zostaÄ‡ obliczony (model logarytmiczny wymaga X > 0).")
    elif np.isnan(r2_lin) and np.isnan(r2_log):
        st.error("Nie moÅ¼na byÅ‚o obliczyÄ‡ Å¼adnego modelu.")
    else:
        # PorÃ³wnanie RÂ²
        if r2_lin > r2_log:
            st.success(f"**Model Liniowy wydaje siÄ™ lepiej dopasowany.** Posiada wyÅ¼szy wspÃ³Å‚czynnik RÂ² ({r2_lin:.4f}) w porÃ³wnaniu do modelu logarytmicznego ({r2_log:.4f}).")
        elif r2_log > r2_lin:
            st.success(f"**Model Logarytmiczny wydaje siÄ™ lepiej dopasowany.** Posiada wyÅ¼szy wspÃ³Å‚czynnik RÂ² ({r2_log:.4f}) w porÃ³wnaniu do modelu liniowego ({r2_lin:.4f}).")
        else:
            st.info(f"Oba modele majÄ… identyczny wspÃ³Å‚czynnik RÂ² ({r2_lin:.4f}).")
            
        # PorÃ³wnanie MSE
        if mse_lin < mse_log:
            st.success(f"Model Liniowy ma rÃ³wnieÅ¼ **mniejszy bÅ‚Ä…d Å›redniokwadratowy (MSE)** ({mse_lin:.4f} vs {mse_log:.4f}), co oznacza, Å¼e jego prognozy sÄ… Å›rednio bliÅ¼sze rzeczywistym wartoÅ›ciom.")
        elif mse_log < mse_lin:
            st.success(f"Model Logarytmiczny ma rÃ³wnieÅ¼ **mniejszy bÅ‚Ä…d Å›redniokwadratowy (MSE)** ({mse_log:.4f} vs {mse_lin:.4f}), co oznacza, Å¼e jego prognozy sÄ… Å›rednio bliÅ¼sze rzeczywistym wartoÅ›ciom.")

    st.subheader("Uwaga na Overfitting (Przeuczenie)")
    st.warning(
        """
        **Czym jest Overfitting?**
        Przeuczenie (overfitting) ma miejsce, gdy model jest zbyt skomplikowany i "uczy siÄ™ na pamiÄ™Ä‡" danych treningowych, w tym szumu, zamiast wychwytywaÄ‡ ogÃ³lny trend. Taki model bÄ™dzie miaÅ‚ Å›wietne wyniki na danych, na ktÃ³rych trenowaÅ‚, ale fatalne na nowych, nieznanych danych.

        **Jak to siÄ™ ma do nas?**
        Modele, ktÃ³rych tu uÅ¼yliÅ›my (liniowy i logarytmiczny z jednÄ… zmiennÄ…), sÄ… modelami **bardzo prostymi**. Ryzyko przeuczenia jest tu **minimalne**. 
        
        DuÅ¼o wiÄ™kszym ryzykiem jest **underfitting** (niedouczenie), czyli sytuacja, w ktÃ³rej model jest zbyt prosty, aby uchwyciÄ‡ prawdziwÄ… zaleÅ¼noÅ›Ä‡ w danych (np. prÃ³ba dopasowania linii prostej do danych, ktÃ³re ukÅ‚adajÄ… siÄ™ w parabolÄ™).

        **Jak rzetelnie oceniÄ‡ model?**
        W prawdziwej analizie predykcyjnej, dane dzieli siÄ™ na **zbiÃ³r treningowy** (do nauki modelu) i **zbiÃ³r testowy** (do jego oceny). Model ocenia siÄ™ na podstawie jego wynikÃ³w (np. RÂ² lub MSE) na zbiorze testowym. W tym module, dla celÃ³w demonstracyjnych, dopasowujemy model do wszystkich dostÄ™pnych danych.
        """
    )
```

-----

## ğŸ“ Integracja z moduÅ‚em "Baza Wiedzy"

Agencie, poniÅ¼szy tekst w formacie Markdown powinien zostaÄ‡ dodany jako nowa strona lub sekcja w istniejÄ…cym module "Baza Wiedzy".

**Instrukcja dla agenta:**

1.  Zlokalizuj plik(i) Pythona odpowiedzialne za moduÅ‚ "Baza Wiedzy" (np. `knowledge_base.py` lub gÅ‚Ã³wny plik `app.py`, gdzie zdefiniowana jest nawigacja).
2.  UtwÃ³rz nowÄ… funkcjÄ™, np. `def show_regression_docs():`.
3.  Wklej poniÅ¼szÄ… treÅ›Ä‡ (caÅ‚Ä… sekcjÄ™ "TreÅ›Ä‡ dla moduÅ‚u Baza Wiedzy") do tej funkcji, uÅ¼ywajÄ…c `st.markdown()`. Upewnij siÄ™, Å¼e renderowanie LaTeX (dla wzorÃ³w) jest wÅ‚Ä…czone (Streamlit domyÅ›lnie to obsÅ‚uguje).
4.  Dodaj w menu nawigacyjnym "Bazy Wiedzy" odnoÅ›nik (np. w `st.selectbox` lub `st.sidebar`) prowadzÄ…cy do funkcji `show_regression_docs()`.

-----

## ğŸ“– TreÅ›Ä‡ dla moduÅ‚u "Baza Wiedzy"

(PoczÄ…tek treÅ›ci do skopiowania)

## ğŸ“ˆ Analiza Regresji: Liniowa i Logarytmiczna

Analiza regresji to jedna z fundamentalnych technik statystycznych. Jej celem jest **modelowanie zaleÅ¼noÅ›ci** miÄ™dzy zmiennymi. NajczÄ™Å›ciej chcemy zrozumieÄ‡, jak jedna zmienna (zaleÅ¼na, $Y$) zmienia siÄ™, gdy zmienia siÄ™ inna zmienna (niezaleÅ¼na, $X$).

### Czym jest Regresja Liniowa?

Regresja liniowa jest najprostszym typem regresji. ZakÅ‚ada ona, Å¼e zaleÅ¼noÅ›Ä‡ miÄ™dzy zmiennÄ… $X$ a $Y$ moÅ¼na opisaÄ‡ za pomocÄ… **linii prostej**.

#### WzÃ³r

Model opisany jest prostym rÃ³wnaniem:

$$
y = ax + b
$$Gdzie:

* **$y$** â€“ WartoÅ›Ä‡ prognozowana (zmienna zaleÅ¼na).
* **$x$** â€“ WartoÅ›Ä‡ zmiennej niezaleÅ¼nej.
* **$a$** â€“ **WspÃ³Å‚czynnik nachylenia** (slope). MÃ³wi nam, o ile *Å›rednio* zmieni siÄ™ $y$, jeÅ›li $x$ wzroÅ›nie o jednÄ… jednostkÄ™.
* **$b$** â€“ **Wyraz wolny** (intercept). Jest to punkt przeciÄ™cia linii z osiÄ… $Y$, czyli wartoÅ›Ä‡ $y$, gdy $x$ wynosi 0.

#### Jak siÄ™ jÄ… liczy?

NajpopularniejszÄ… metodÄ… jest **Metoda Najmniejszych KwadratÃ³w (Ordinary Least Squares - OLS)**. Komputer szuka takiej linii (czyli takich wartoÅ›ci $a$ i $b$), ktÃ³ra minimalizuje sumÄ™ kwadratÃ³w odlegÅ‚oÅ›ci (tzw. "bÅ‚Ä™dÃ³w" lub "rezyduÃ³w") miÄ™dzy rzeczywistymi punktami danych a liniÄ… regresji.

#### Kiedy jej uÅ¼ywaÄ‡?

* Gdy na wykresie punktowym dane wydajÄ… siÄ™ ukÅ‚adaÄ‡ wzdÅ‚uÅ¼ linii prostej.
* Gdy zakÅ‚adamy staÅ‚e tempo zmiany (np. koszt wyprodukowania 10 sztuk jest 10 razy wiÄ™kszy niÅ¼ 1 sztuki).
* Jako model bazowy do porÃ³wnania z bardziej skomplikowanymi modelami.

-----

### Czym jest Regresja Logarytmiczna?

Regresja logarytmiczna jest modelem krzywoliniowym. Jest idealna do opisywania sytuacji, w ktÃ³rych zaleÅ¼noÅ›Ä‡ **szybko roÅ›nie na poczÄ…tku, a nastÄ™pnie zwalnia** (lub nasyca siÄ™).

#### WzÃ³r

Model opisany jest rÃ³wnaniem:

$$y = a \\cdot \\ln(x) + b
$$Gdzie:

  * **$y$**, **$a$**, **$b$** â€“ MajÄ… podobne znaczenie jak w regresji liniowej.
  * **$\ln(x)$** â€“ **Logarytm naturalny** ze zmiennej $x$.

**WaÅ¼na uwaga:** Model ten moÅ¼na stosowaÄ‡ tylko wtedy, gdy wartoÅ›ci zmiennej niezaleÅ¼nej $X$ sÄ… **dodatnie** ($x > 0$), poniewaÅ¼ logarytm z zera lub liczb ujemnych jest niezdefiniowany.

#### Jak siÄ™ jÄ… liczy?

NajczÄ™Å›ciej sprowadza siÄ™ to do prostego triku:

1.  Tworzymy nowÄ… zmiennÄ…, $X' = \ln(X)$.
2.  Wykonujemy **regresjÄ™ liniowÄ…** na danych $(X', Y)$.
    Model, ktÃ³ry otrzymujemy, to $y = a \cdot X' + b$, co po podstawieniu $X'$ daje nam $y = a \cdot \ln(x) + b$.

#### Kiedy jej uÅ¼ywaÄ‡?

  * Gdy obserwujemy **prawo malejÄ…cych przychodÃ³w**. Na przykÅ‚ad:
      * WpÅ‚yw wydatkÃ³w na reklamÄ™ na sprzedaÅ¼ (pierwsza wydana zÅ‚otÃ³wka przynosi duÅ¼y zwrot, ale milionowa juÅ¼ znacznie mniejszy).
      * WpÅ‚yw liczby godzin nauki na wynik egzaminu (przejÅ›cie z 0 na 2 godziny daje duÅ¼y skok; przejÅ›cie z 10 na 12 godzin â€“ niewielki).
  * Gdy tempo wzrostu $Y$ maleje wraz ze wzrostem $X$.

-----

### Jak oceniÄ‡, ktÃ³ry model jest lepszy?

Po dopasowaniu obu modeli do tych samych danych, musimy zdecydowaÄ‡, ktÃ³ry z nich jest lepszy. UÅ¼ywamy do tego dwÃ³ch kluczowych metryk:

#### 1\. R-kwadrat (RÂ²) â€“ WspÃ³Å‚czynnik Determinacji

  * **Co mierzy:** Jak dobrze model (linia lub krzywa) **wyjaÅ›nia zmiennoÅ›Ä‡** w danych.
  * **Interpretacja:** Jest to wartoÅ›Ä‡ od 0 do 1 (lub 0% do 100%).
      * RÂ² = 0.85 oznacza, Å¼e 85% zmiennoÅ›ci w $Y$ jest wyjaÅ›niane przez zmiennÄ… $X$ za pomocÄ… naszego modelu.
  * **WybÃ³r:** **Im wyÅ¼szy RÂ², tym (zazwyczaj) lepszy model.** Lepsze dopasowanie do danych.

#### 2\. BÅ‚Ä…d Åšredniokwadratowy (Mean Squared Error - MSE)

  * **Co mierzy:** ÅšredniÄ… kwadratÃ³w bÅ‚Ä™dÃ³w (rÃ³Å¼nic miÄ™dzy wartoÅ›ciÄ… rzeczywistÄ… $y$ a prognozowanÄ… $\hat{y}$).
  * **Interpretacja:** Jest to miara bÅ‚Ä™du prognozy. PoniewaÅ¼ bÅ‚Ä™dy sÄ… podnoszone do kwadratu, metryka ta bardzo **mocno "karze" duÅ¼e bÅ‚Ä™dy**.
  * **WybÃ³r:** **Im niÅ¼szy MSE, tym lepszy model.** Oznacza to, Å¼e prognozy modelu sÄ… Å›rednio bliÅ¼sze prawdy.

#### Wnioskowanie:

NajczÄ™Å›ciej szukamy modelu, ktÃ³ry ma **jednoczeÅ›nie wysoki RÂ² i niski MSE**.

### Problem Overfittingu (Przeuczenia)

Overfitting to jeden z najwiÄ™kszych problemÃ³w w modelowaniu.

  * **Definicja:** Zjawisko, w ktÃ³rym model jest **zbyt skomplikowany** i zamiast uczyÄ‡ siÄ™ ogÃ³lnego trendu w danych, zaczyna "wkuwaÄ‡ na pamiÄ™Ä‡" dane treningowe, Å‚Ä…cznie z przypadkowym szumem.
  * **Skutek:** Taki model ma fantastyczne metryki (np. RÂ² bliskie 1.0) na danych, na ktÃ³rych byÅ‚ uczony, ale kompletnie nie potrafi przewidywaÄ‡ nowych, nieznanych mu danych.
  * **Jak siÄ™ chroniÄ‡:** W przypadku prostych modeli (jak regresja liniowa czy logarytmiczna z jednÄ… zmiennÄ…) ryzyko jest bardzo maÅ‚e. Problem pojawia siÄ™ przy modelach bardzo zÅ‚oÅ¼onych (np. wielomiany wysokiego stopnia, gÅ‚Ä™bokie sieci neuronowe).
  * **Podstawowa zasada:** Zawsze naleÅ¼y dÄ…Å¼yÄ‡ do modelu **moÅ¼liwie najprostszego**, ktÃ³ry wciÄ…Å¼ dobrze wyjaÅ›nia dane (tzw. "Zasada OszczÄ™dnoÅ›ci" lub "Brzytwa Ockhama").

(Koniec treÅ›ci do skopiowania)