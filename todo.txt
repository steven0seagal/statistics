Oto ultra-dokÅ‚adny, 12-krokowy plan implementacji dla agenta (programisty), ktÃ³ry ma zintegrowaÄ‡ moduÅ‚ "Automatycznego Rekomendowania i Wykonywania TestÃ³w" z istniejÄ…cÄ… aplikacjÄ… Streamlit.

-----

## ğŸš€ Plan Implementacji: ModuÅ‚ Rekomendacji i Analizy Statystycznej

### Krok 1: Stworzenie Pliku ModuÅ‚u i Integracja z GÅ‚Ã³wnÄ… AplikacjÄ…

**Cel:** Stworzenie dedykowanego pliku Python dla nowej funkcjonalnoÅ›ci i podÅ‚Ä…czenie go do gÅ‚Ã³wnej nawigacji aplikacji. Zapewnia to modularnoÅ›Ä‡ i czystoÅ›Ä‡ kodu.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  W gÅ‚Ã³wnym folderze projektu stwÃ³rz nowy plik: `statistical_recommender.py`.
2.  W tym pliku zdefiniuj gÅ‚Ã³wnÄ… funkcjÄ™, ktÃ³ra bÄ™dzie zawieraÄ‡ caÅ‚Ä… logikÄ™ tego moduÅ‚u, np. `def run_recommender_tool():`.
3.  Upewnij siÄ™, Å¼e na poczÄ…tku `statistical_recommender.py` importujesz wszystkie niezbÄ™dne biblioteki:
    ```python
    import streamlit as st
    import pandas as pd
    import scipy.stats as stats
    from statsmodels.stats.anova import anova_lm # Dla ANOVA
    from statsmodels.formula.api import ols # Dla ANOVA
    import numpy as np
    import openpyxl # Wymagane przez pandas do .xlsx
    ```
4.  W gÅ‚Ã³wnym pliku aplikacji (np. `app.py`):
      * Zaimportuj nowy moduÅ‚: `import statistical_recommender`.
      * ZnajdÅº logikÄ™ nawigacji (prawdopodobnie `st.sidebar.selectbox` lub podobny).
      * Dodaj nowÄ… opcjÄ™ do wyboru, np. "Rekomender TestÃ³w Statystycznych".
      * W bloku `if/elif` wywoÅ‚aj funkcjÄ™ z nowego moduÅ‚u:
        ```python
        # W app.py
        app_choice = st.sidebar.selectbox("Wybierz narzÄ™dzie", ["Strona GÅ‚Ã³wna", "Rekomender TestÃ³w Statystycznych", "Inne..."])

        if app_choice == "Strona GÅ‚Ã³wna":
            # ...
        elif app_choice == "Rekomender TestÃ³w Statystycznych":
            statistical_recommender.run_recommender_tool()
        ```

-----

### Krok 2: Interfejs UÅ¼ytkownika (UI) do Wgrywania Danych i Opcji Parsowania

**Cel:** UmoÅ¼liwienie uÅ¼ytkownikowi wgrania pliku (`.csv`, `.tsv`, `.xlsx`) i natychmiastowe zdefiniowanie kluczowych opcji formatowania (np. separatora), aby zapobiec bÅ‚Ä™dom wczytywania.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  W funkcji `run_recommender_tool()` dodaj tytuÅ‚ i uploader plikÃ³w:
    ```python
    st.title("ğŸ¤– Automatyczny Rekomender TestÃ³w Statystycznych")
    uploaded_file = st.file_uploader("Krok 1: Wgraj swÃ³j plik z danymi", type=["csv", "tsv", "xlsx"], on_change=clear_session_state_on_new_file)
    ```
      * **WaÅ¼ne:** UÅ¼ycie `on_change` jest kluczowe. WskaÅ¼ mu funkcjÄ™ (ktÃ³rÄ… zdefiniujesz w Kroku 12), ktÃ³ra wyczyÅ›ci caÅ‚y `st.session_state`, gdy uÅ¼ytkownik wgra *nowy* plik.
2.  Dodaj ekspander (`st.expander`) na opcje formatowania. Pojawi siÄ™ on *tylko*, gdy plik jest wgrany.
    ```python
    if uploaded_file is not None:
        with st.expander("Opcje Å‚adowania danych"):
            # Opcje specyficzne dla CSV/TSV
            if uploaded_file.name.endswith(('.csv', '.tsv')):
                delimiter = st.radio("Wybierz separator (delimiter):", (',', ';', '\t', ' '), horizontal=True, key='file_delimiter')
            # Opcje specyficzne dla Excela
            elif uploaded_file.name.endswith('.xlsx'):
                sheet_name = st.text_input("Podaj nazwÄ™ arkusza (zostaw puste dla pierwszego)", key='file_sheet')
    ```
      * UÅ¼ywaj unikalnych kluczy (`key=...`), aby Streamlit poprawnie zarzÄ…dzaÅ‚ stanem tych widgetÃ³w.

-----

### Krok 3: Logika Åadowania Danych i Cache'owania (Backend)

**Cel:** Stworzenie funkcji, ktÃ³ra bezpiecznie wczyta dane do DataFrame Pandas, obsÅ‚ugujÄ…c rÃ³Å¼ne formaty i opcje. Funkcja *musi* byÄ‡ cache'owana, aby uniknÄ…Ä‡ ponownego Å‚adowania pliku przy kaÅ¼dej interakcji uÅ¼ytkownika.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Zdefiniuj funkcjÄ™ Å‚adujÄ…cÄ… z dekoratorem `@st.cache_data`. Ten dekorator jest niezbÄ™dny dla wydajnoÅ›ci.
2.  Funkcja musi przyjmowaÄ‡ obiekt pliku oraz opcje parsowania jako argumenty, aby cache poprawnie siÄ™ resetowaÅ‚, gdy zmieniÄ… siÄ™ opcje.
    ```python
    @st.cache_data
    def load_data(file, delimiter=None, sheet_name=None):
        try:
            if file.name.endswith(('.csv', '.tsv')):
                # UÅ¼yj domyÅ›lnego separatora, jeÅ›li nie zostaÅ‚ podany
                sep = delimiter if delimiter else ','
                df = pd.read_csv(file, sep=sep)
            elif file.name.endswith('.xlsx'):
                # UÅ¼yj None (co oznacza pierwszy arkusz) lub podanej nazwy
                sn = sheet_name if sheet_name else 0 
                df = pd.read_excel(file, sheet_name=sn)
            return df
        except Exception as e:
            st.error(f"BÅ‚Ä…d podczas Å‚adowania pliku: {e}")
            return None
    ```
3.  WywoÅ‚aj tÄ™ funkcjÄ™ w gÅ‚Ã³wnym przepÅ‚ywie, przekazujÄ…c opcje z `st.session_state` (Streamlit automatycznie przechowa tam wartoÅ›ci z widgetÃ³w dziÄ™ki uÅ¼ytym `key`):
    ```python
    if uploaded_file is not None:
        # ... (kod expandera z Kroku 2) ...
        
        # Pobierz opcje ze stanu lub uÅ¼yj domyÅ›lnych
        delimiter_opt = st.session_state.get('file_delimiter', ',')
        sheet_opt = st.session_state.get('file_sheet', None)

        df = load_data(uploaded_file, delimiter_opt, sheet_opt)
    ```

-----

### Krok 4: ZarzÄ…dzanie Stanem Sesji i WyÅ›wietlanie PodglÄ…du Danych

**Cel:** Zapisanie wczytanego DataFrame w `st.session_state`, aby byÅ‚ dostÄ™pny dla wszystkich kolejnych krokÃ³w (wybÃ³r kolumn, analiza) bez potrzeby ponownego Å‚adowania. UÅ¼ycie `st.session_state` jest fundamentem wieloetapowych aplikacji w Streamlit.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Gdy `df` zostanie pomyÅ›lnie zaÅ‚adowany (nie jest `None`), natychmiast zapisz go w stanie sesji i pokaÅ¼ podglÄ…d.
    ```python
    if df is not None:
        st.session_state['data'] = df # KLUCZOWY KROK
        st.header("PodglÄ…d Danych (pierwsze 5 wierszy)")
        st.dataframe(df.head())
    ```
2.  CaÅ‚a reszta logiki moduÅ‚u (Kroki 5-11) musi byÄ‡ teraz umieszczona wewnÄ…trz bloku `if 'data' in st.session_state:`. Gwarantuje to, Å¼e interfejs do analizy pojawi siÄ™ *dopiero* po pomyÅ›lnym zaÅ‚adowaniu danych.
    ```python
    # ... (kod do Å‚adowania danych) ...

    # GÅ‚Ã³wny blok przepÅ‚ywu analizy
    if 'data' in st.session_state:
        df = st.session_state['data'] # Pobierz df ze stanu
        
        # ... (Tutaj umieÅ›cisz Kroki 5, 6, 7, 8, 9, 10, 11) ...
    ```

-----

### Krok 5: Interfejs UÅ¼ytkownika (UI) do Wyboru Kolumn

**Cel:** UmoÅ¼liwienie uÅ¼ytkownikowi wybrania (jednej lub wiÄ™cej) kolumn z wczytanych danych, ktÃ³re chce poddaÄ‡ analizie.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  WewnÄ…trz bloku `if 'data' in st.session_state:` dodaj `st.multiselect`.
2.  Zapisz wybÃ³r uÅ¼ytkownika rÃ³wnieÅ¼ w `st.session_state`. UÅ¼yj `on_change`, aby wyczyÅ›ciÄ‡ *stare wyniki analizy* (ale nie wczytane dane\!), gdy uÅ¼ytkownik zmieni kolumny.
    ```python
    st.header("Krok 2: Wybierz kolumny do analizy")
    st.info("Wybierz kolumny, ktÃ³re chcesz porÃ³wnaÄ‡. Rekomendacja bÄ™dzie zaleÅ¼eÄ‡ od ich typÃ³w i liczby.")

    all_columns = df.columns.tolist()
    selected_columns = st.multiselect(
        "Wybierz kolumny:",
        all_columns,
        key='selected_columns',
        on_change=clear_analysis_results # Funkcja do zdefiniowania w Kroku 12
    )
    ```
      * Funkcja `clear_analysis_results` powinna usuwaÄ‡ klucze takie jak `'profile'`, `'assumptions'`, `'recommendation'`, `'results'`.

-----

### Krok 6: Profilowanie Kolumn i Sprawdzanie ZaÅ‚oÅ¼eÅ„ (Backend)

**Cel:** Automatyczne uruchomienie logiki, ktÃ³ra analizuje wybrane kolumny. Sprawdza ich typ (numeryczny/kategoryczny) oraz kluczowe zaÅ‚oÅ¼enia, jak normalnoÅ›Ä‡ rozkÅ‚adu (dla zmiennych numerycznych).

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  StwÃ³rz funkcjÄ™ `def profile_and_test_columns(df, cols):`.
2.  Ta funkcja powinna iterowaÄ‡ po `cols` i budowaÄ‡ sÅ‚ownik "profilu".
3.  **Wykrywanie Typu:** UÅ¼yj `pd.api.types.is_numeric_dtype(df[col])` do rozrÃ³Å¼nienia.
4.  **Heurystyka Kategoryczna:** JeÅ›li kolumna nie jest numeryczna, sprawdÅº `df[col].nunique()`. JeÅ›li ma \>50 unikalnych wartoÅ›ci (lub inny prÃ³g), traktuj jÄ… jako "Tekst/ID"; jeÅ›li mniej, traktuj jako "Kategoryczna".
5.  **Test NormalnoÅ›ci:** Dla kaÅ¼dej kolumny numerycznej, uruchom test Shapiro-Wilka. UÅ¼yj `stats.shapiro(df[col].dropna())`. Zapisz p-wartoÅ›Ä‡. ObsÅ‚uÅ¼ bÅ‚Ä™dy (np. gdy jest za maÅ‚o danych).
6.  **Test HomogenicznoÅ›ci Wariancji:** JeÅ›li wybrano DOKÅADNIE 1 kolumnÄ™ kategorycznÄ… i 1 numerycznÄ…, uruchom test Levene'a. Musisz przygotowaÄ‡ dane: `groups_data = [df[num_col][df[cat_col] == g].dropna() for g in df[cat_col].unique()]`. NastÄ™pnie `stats.levene(*groups_data)`. Zapisz p-wartoÅ›Ä‡.
7.  Funkcja powinna zwracaÄ‡ dwa sÅ‚owniki: `profile` (informacje o kaÅ¼dej kolumnie) i `assumptions` (wyniki testÃ³w interakcji, jak Levene'a).
    ```python
    # PrzykÅ‚adowa struktura zwracana przez funkcjÄ™:
    profile = {
        'Wiek': {'type': 'Numeric', 'is_normal': False, 'p_shapiro': 0.001},
        'Grupa': {'type': 'Categorical', 'unique_values': 3}
    }
    assumptions = {
        'homoscedasticity': True, 'p_levene': 0.15
    }
    ```
8.  WywoÅ‚aj tÄ™ funkcjÄ™, gdy tylko uÅ¼ytkownik wybierze kolumny, i zapisz wyniki w stanie:
    ```python
    if len(st.session_state.get('selected_columns', [])) > 0:
        cols = st.session_state['selected_columns']
        profile, assumptions = profile_and_test_columns(df, cols)
        st.session_state['profile'] = profile
        st.session_state['assumptions'] = assumptions
    ```

-----

### Krok 7: WyÅ›wietlanie ZaÅ‚oÅ¼eÅ„ i Logika Rekomendacji (UI + Backend)

**Cel:** WyÅ›wietlenie uÅ¼ytkownikowi wynikÃ³w analizy zaÅ‚oÅ¼eÅ„ (Krok 6) i uruchomienie "silnika rekomendacji" (drzewa decyzyjnego), aby wybraÄ‡ odpowiedni test.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  **WyÅ›wietlanie ZaÅ‚oÅ¼eÅ„ (UI):** JeÅ›li `'profile'` istnieje w stanie, wyÅ›wietl go.
    ```python
    if 'profile' in st.session_state:
        st.header("Krok 3: Automatyczna Analiza ZaÅ‚oÅ¼eÅ„")
        with st.expander("Zobacz szczegÃ³Å‚y analizy kolumn", expanded=False):
            st.json(st.session_state['profile'])
        if 'assumptions' in st.session_state:
            st.json(st.session_state['assumptions'])
    ```
2.  **Silnik Rekomendacji (Backend):** StwÃ³rz funkcjÄ™ `def get_recommendation(profile, assumptions, selected_cols):`.
      * Najpierw policz: `num_numeric = len([p for p in profile.values() if p['type'] == 'Numeric'])` i `num_categorical`.
      * Zbuduj drzewo decyzyjne `if/elif`:
        ```python
        # WewnÄ…trz get_recommendation()
        if num_numeric == 1 and num_categorical == 1:
            cat_col_name = ...
            num_groups = profile[cat_col_name]['unique_values']
            is_normal = list(profile.values())...['is_normal']
            is_homoscedastic = assumptions.get('homoscedasticity', False)

            if num_groups == 2:
                if is_normal and is_homoscedastic:
                    return {'name': 'Test t dla prÃ³b niezaleÅ¼nych', 'key': 'ttest_ind', ...}
                elif is_normal and not is_homoscedastic:
                    return {'name': 'Test t Welcha', 'key': 'ttest_welch', ...}
                else:
                    return {'name': 'Test U Manna-Whitneya', 'key': 'mannwhitneyu', ...}
            elif num_groups > 2:
                if is_normal and is_homoscedastic:
                    return {'name': 'Jednoczynnikowa ANOVA', 'key': 'anova', ...}
                else: # Uproszczenie: dla braku normalnoÅ›ci lub rÃ³wnoÅ›ci wariancji
                    return {'name': 'Test Kruskala-Wallisa', 'key': 'kruskal', ...}

        elif num_numeric == 2 and num_categorical == 0:
            # ... logika dla korelacji (Pearson/Spearman) ...
            return {'name': 'Korelacja Pearsona', 'key': 'pearsonr', ...}

        elif num_numeric == 0 and num_categorical == 2:
            return {'name': 'Test Chi-kwadrat', 'key': 'chi2', ...}

        else:
            return {'name': 'Brak testu', 'key': None, 'reason': 'Wybierz innÄ… kombinacjÄ™...'}
        ```
      * **Kluczowe:** SÅ‚ownik rekomendacji *musi* zawieraÄ‡ unikalny klucz (`'key'`) identyfikujÄ…cy funkcjÄ™ testujÄ…cÄ… do uruchomienia.
3.  WywoÅ‚aj silnik i zapisz wynik w stanie:
    ```python
    if 'profile' in st.session_state:
        # ... (kod wyÅ›wietlania profilu) ...
        rec = get_recommendation(st.session_state['profile'], st.session_state['assumptions'], st.session_state['selected_columns'])
        st.session_state['recommendation'] = rec
        
        st.header("Krok 4: Rekomendacja Testu")
        st.success(f"**Sugerowany test:** {rec['name']}")
        st.info(f"**Uzasadnienie:** {rec['reason']}")
    ```

-----

### Krok 8: Przycisk Wykonania Analizy (UI)

**Cel:** UdostÄ™pnienie przycisku, ktÃ³ry pozwala uÅ¼ytkownikowi *zaakceptowaÄ‡* rekomendacjÄ™ i uruchomiÄ‡ peÅ‚nÄ… analizÄ™.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Ten przycisk powinien pojawiÄ‡ siÄ™ tylko wtedy, gdy istnieje waÅ¼na rekomendacja (klucz nie jest `None`).
2.  KlikniÄ™cie przycisku powinno jedynie ustawiÄ‡ flagÄ™ w `st.session_state`. WÅ‚aÅ›ciwa analiza zostanie uruchomiona w Kroku 9.
    ```python
    if 'recommendation' in st.session_state and st.session_state['recommendation']['key'] is not None:
        rec_name = st.session_state['recommendation']['name']
        if st.button(f"âœ… Tak, wykonaj analizÄ™ ({rec_name})", type="primary"):
            st.session_state['run_analysis_flag'] = True
    ```

-----

### Krok 9: Router Funkcji Statystycznych (Backend)

**Cel:** Stworzenie "routera", ktÃ³ry na podstawie flagi z Kroku 8 i klucza z rekomendacji (`'key'`) wywoÅ‚a odpowiedniÄ… funkcjÄ™ statystycznÄ… (zdefiniowanÄ… w Kroku 10).

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  UmieÅ›Ä‡ tÄ™ logikÄ™ na samym koÅ„cu gÅ‚Ã³wnego bloku `if 'data' in st.session_state:`.
2.  SprawdÅº, czy flaga `run_analysis_flag` jest ustawiona na `True`.
3.  JeÅ›li tak, pobierz klucz testu, wywoÅ‚aj gÅ‚Ã³wny router, zapisz wyniki w stanie, a nastÄ™pnie *natychmiast zresetuj flagÄ™* (aby test nie uruchamiaÅ‚ siÄ™ w kÃ³Å‚ko).
    ```python
    if st.session_state.get('run_analysis_flag', False):
        df = st.session_state['data']
        cols = st.session_state['selected_columns']
        rec_key = st.session_state['recommendation']['key']
        
        with st.spinner("Przeprowadzanie analizy statystycznej..."):
            # WywoÅ‚aj router, ktÃ³ry wywoÅ‚a wÅ‚aÅ›ciwy test
            results = run_statistical_test(df, cols, rec_key)
            st.session_state['results'] = results
        
        st.session_state['run_analysis_flag'] = False # Resetuj flagÄ™!
    ```
4.  Zdefiniuj funkcjÄ™ routera `run_statistical_test(df, cols, key)`:
    ```python
    def run_statistical_test(df, cols, key):
        if key == 'ttest_ind':
            return run_ttest_ind(df, cols) # Funkcja z Kroku 10
        elif key == 'anova':
            return run_anova(df, cols) # Funkcja z Kroku 10
        elif key == 'chi2':
            return run_chi2(df, cols) # Funkcja z Kroku 10
        # ... (itd. dla kaÅ¼dego testu)
        else:
            return {'error': 'Nie znaleziono funkcji testujÄ…cej'}
    ```

-----

### Krok 10: Implementacja PoszczegÃ³lnych Funkcji TestujÄ…cych (Backend)

**Cel:** Stworzenie oddzielnych funkcji dla *kaÅ¼dego* testu statystycznego. KaÅ¼da funkcja musi zwracaÄ‡ *ustandaryzowany sÅ‚ownik wynikÃ³w*.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Zdefiniuj funkcjÄ™ dla kaÅ¼dego klucza z Kroku 7 (np. `run_ttest_ind`, `run_anova`, `run_chi2`).
2.  KaÅ¼da funkcja musi:
    a. WyodrÄ™bniÄ‡ odpowiednie kolumny (np. znaleÅºÄ‡, ktÃ³ra jest numeryczna, a ktÃ³ra kategoryczna).
    b. PrzygotowaÄ‡ dane (np. stworzyÄ‡ grupy dla testu t).
    c. UruchomiÄ‡ test za pomocÄ… `scipy.stats` lub `statsmodels`.
    d. SformatowaÄ‡ hipotezy (H0, H1) jako stringi.
    e. ZinterpretowaÄ‡ p-wartoÅ›Ä‡ (PoniÅ¼ej / PowyÅ¼ej 0.05).
    f. ZwrÃ³ciÄ‡ sÅ‚ownik o *tej samej strukturze*.
3.  **PrzykÅ‚ad (Test t):**
    ```python
    def run_ttest_ind(df, cols):
        # Logika do znalezienia, ktÃ³ra kolumna jest num_col, a ktÃ³ra cat_col
        num_col = ... 
        cat_col = ...
        
        groups = df[cat_col].unique()
        data1 = df[df[cat_col] == groups[0]][num_col].dropna()
        data2 = df[df[cat_col] == groups[1]][num_col].dropna()
        
        stat, p_value = stats.ttest_ind(data1, data2)
        
        h0 = f"Åšrednia wartoÅ›Ä‡ '{num_col}' jest taka sama dla grupy '{groups[0]}' i '{groups[1]}'."
        h1 = f"Åšrednia wartoÅ›Ä‡ '{num_col}' rÃ³Å¼ni siÄ™ istotnie miÄ™dzy grupami."
        
        alpha = 0.05
        if p_value < alpha:
            interpretation = f"PoniewaÅ¼ p-wartoÅ›Ä‡ ({p_value:.4f}) jest mniejsza niÅ¼ {alpha}, odrzucamy hipotezÄ™ zerowÄ… (H0)."
            conclusion = "Stwierdzono statystycznie istotnÄ… rÃ³Å¼nicÄ™ miÄ™dzy grupami."
        else:
            interpretation = f"PoniewaÅ¼ p-wartoÅ›Ä‡ ({p_value:.4f}) jest wiÄ™ksza niÅ¼ {alpha}, brak podstaw do odrzucenia hipotezy zerowej (H0)."
            conclusion = "Nie stwierdzono statystycznie istotnej rÃ³Å¼nicy miÄ™dzy grupami."
            
        return {
            'test_name': 'Test t dla prÃ³b niezaleÅ¼nych',
            'statistic_name': 't-statistic',
            'statistic_value': stat,
            'p_value': p_value,
            'h0': h0,
            'h1': h1,
            'interpretation': interpretation,
            'conclusion': conclusion
        }
    ```
4.  **PrzykÅ‚ad (ANOVA):** BÄ™dziesz potrzebowaÄ‡ `statsmodels`.
    ```python
    def run_anova(df, cols):
        # num_col = ..., cat_col = ...
        model = ols(f'Q("{num_col}") ~ C(Q("{cat_col}"))', data=df).fit()
        anova_table = anova_lm(model, typ=2)
        
        p_value = anova_table['PR(>F)'][0]
        f_value = anova_table['F'][0]
        # ... (reszta logiki formatowania H0, H1, interpretacji) ...
        
        return {
            'test_name': 'Jednoczynnikowa ANOVA',
            'statistic_name': 'F-statistic',
            'statistic_value': f_value,
            'p_value': p_value,
            # ... (h0, h1, interpretation, conclusion) ...
        }
    ```

-----

### Krok 11: WyÅ›wietlanie KoÅ„cowego Raportu z Wynikami (UI)

**Cel:** Zaprezentowanie uÅ¼ytkownikowi peÅ‚nego raportu z analizy w czytelny i uporzÄ…dkowany sposÃ³b.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Na samym dole, wewnÄ…trz `if 'data' in st.session_state:`, dodaj blok sprawdzajÄ…cy, czy istniejÄ… wyniki.
2.  UÅ¼yj `st.header`, `st.subheader`, `st.metric` i `st.info`/`st.success`, aby sformatowaÄ‡ ustandaryzowany sÅ‚ownik wynikÃ³w.
    ```python
    if 'results' in st.session_state:
        results = st.session_state['results']
        
        st.header(f"Krok 5: Wyniki Analizy ({results['test_name']})")
        st.markdown("---")
        
        st.subheader("SformuÅ‚owane Hipotezy")
        st.markdown(f"**Hipoteza Zerowa (H0):** {results['h0']}")
        st.markdown(f"**Hipoteza Alternatywna (H1):** {results['h1']}")
        
        st.subheader("Wyniki Testu")
        col1, col2 = st.columns(2)
        col1.metric(results['statistic_name'], f"{results['statistic_value']:.4f}")
        col2.metric("P-wartoÅ›Ä‡ (p-value)", f"{results['p_value']:.4f}")
        
        st.subheader("Interpretacja i Wnioski (dla poziomu istotnoÅ›ci Î± = 0.05)")
        st.info(f"**Interpretacja:** {results['interpretation']}")
        st.success(f"**Wniosek:** {results['conclusion']}")
    ```

-----

### Krok 12: Funkcje CzyszczÄ…ce Stan Sesji (Backend)

**Cel:** Zapewnienie, Å¼e stan aplikacji jest poprawnie resetowany, gdy uÅ¼ytkownik zmienia dane wejÅ›ciowe, aby uniknÄ…Ä‡ wyÅ›wietlania starych wynikÃ³w dla nowych danych.

**SzczegÃ³Å‚owy Opis dla Agenta:**

1.  Zdefiniuj dwie funkcje czyszczÄ…ce. Najlepiej na gÃ³rze pliku `statistical_recommender.py`.
2.  **Funkcja 1: Resetowanie wszystkiego** (gdy wgrywany jest nowy plik).
    ```python
    def clear_session_state_on_new_file():
        # Klucze do usuniÄ™cia
        keys_to_clear = ['data', 'selected_columns', 'profile', 'assumptions', 'recommendation', 'results', 'run_analysis_flag']
        for key in keys_to_clear:
            if key in st.session_state:
                del st.session_state[key]
    ```
3.  **Funkcja 2: Resetowanie tylko analizy** (gdy zmieniane sÄ… kolumny).
    ```python
    def clear_analysis_results():
        # Klucze do usuniÄ™cia (zostawiamy 'data'!)
        keys_to_clear = ['profile', 'assumptions', 'recommendation', 'results', 'run_analysis_flag']
        for key in keys_to_clear:
            if key in st.session_state:
                del st.session_state[key]
    ```
4.  Upewnij siÄ™, Å¼e te funkcje sÄ… poprawnie podÅ‚Ä…czone do parametrÃ³w `on_change` w widgetach (jak opisano w Kroku 2 i 5).



### Krok 13. Demo data

Dodatkowo wygeneruj demo data ktÃ³re byÅ‚yby odpowiednie dla kaÅ¼dego testu statustycznego 


### Krok 14 Biblioteka TestÃ³w Statystycznych do Implementacji

Oto docelowa lista testÃ³w, ktÃ³re silnik rekomendacji i analizy musi obsÅ‚ugiwaÄ‡. Podzielono je wedÅ‚ug scenariuszy wyboru kolumn przez uÅ¼ytkownika.

I. Testy PorÃ³wnawcze (PorÃ³wnywanie Åšrednich/Median)
Te testy sÄ… uÅ¼ywane, gdy uÅ¼ytkownik chce porÃ³wnaÄ‡ wartoÅ›ci liczbowe miÄ™dzy rÃ³Å¼nymi grupami.

Scenariusz 1: 1 Zmienna Kategoryczna (2 grupy) + 1 Zmienna Numeryczna (PrzykÅ‚ad: PorÃ³wnanie 'Wzrostu' (Num) miÄ™dzy 'MÄ™Å¼czyzna' i 'Kobieta' (Kat))

Test 1: Test t dla prÃ³b niezaleÅ¼nych (Independent T-test)

Kiedy: Gdy zmienna numeryczna ma rozkÅ‚ad normalny ORAZ wariancje w obu grupach sÄ… rÃ³wne (test Levene'a > 0.05).

Hipoteza (H0): Åšrednie w obu grupach sÄ… rÃ³wne.

Klucz implementacji: ttest_ind

Biblioteka: scipy.stats.ttest_ind(data1, data2, equal_var=True)

Test 2: Test t Welcha (Welch's T-test)

Kiedy: Gdy zmienna numeryczna ma rozkÅ‚ad normalny, ALE wariancje w grupach sÄ… rÃ³Å¼ne (test Levene'a <= 0.05).

Hipoteza (H0): Åšrednie w obu grupach sÄ… rÃ³wne.

Klucz implementacji: ttest_welch

Biblioteka: scipy.stats.ttest_ind(data1, data2, equal_var=False)

Test 3: Test U Manna-Whitneya (Mann-Whitney U Test)

Kiedy: Gdy zmienna numeryczna NIE ma rozkÅ‚adu normalnego (test Shapiro-Wilka <= 0.05). Jest to test nieparametryczny.

Hipoteza (H0): RozkÅ‚ady (lub mediany) w obu grupach sÄ… takie same.

Klucz implementacji: mannwhitneyu

Biblioteka: scipy.stats.mannwhitneyu(data1, data2)

Scenariusz 2: 1 Zmienna Kategoryczna (3+ grupy) + 1 Zmienna Numeryczna (PrzykÅ‚ad: PorÃ³wnanie 'Wyniku testu' (Num) miÄ™dzy 'Grupa A', 'Grupa B' i 'Grupa C' (Kat))

Test 4: Jednoczynnikowa Analiza Wariancji (One-Way ANOVA)

Kiedy: Gdy zmienna numeryczna ma rozkÅ‚ad normalny ORAZ wariancje we wszystkich grupach sÄ… rÃ³wne (test Levene'a > 0.05).

Hipoteza (H0): Åšrednie we wszystkich grupach sÄ… rÃ³wne.

Klucz implementacji: anova

Biblioteka: scipy.stats.f_oneway(grupa1, grupa2, grupa3, ...) LUB (lepiej) statsmodels dla peÅ‚nej tabeli.

Test 5: Test Kruskala-Wallisa (Kruskal-Wallis H Test)

Kiedy: Gdy zmienna numeryczna NIE ma rozkÅ‚adu normalnego LUB wariancje NIE sÄ… rÃ³wne. Jest to test nieparametryczny.

Hipoteza (H0): RozkÅ‚ady (lub mediany) we wszystkich grupach sÄ… takie same.

Klucz implementacji: kruskal

Biblioteka: scipy.stats.kruskal(grupa1, grupa2, grupa3, ...)

II. Testy ZaleÅ¼noÅ›ci (Sprawdzanie Relacji)
Te testy sÄ… uÅ¼ywane do sprawdzenia, czy dwie zmienne sÄ… ze sobÄ… powiÄ…zane.

Scenariusz 3: 2 Zmienne Numeryczne (PrzykÅ‚ad: Sprawdzenie relacji miÄ™dzy 'Wzrostem' a 'WagÄ…')

Test 6: WspÃ³Å‚czynnik Korelacji r Pearsona

Kiedy: Gdy OBIE zmienne numeryczne majÄ… rozkÅ‚ad normalny.

Hipoteza (H0): Nie ma liniowej korelacji miÄ™dzy zmiennymi (wspÃ³Å‚czynnik = 0).

Klucz implementacji: pearsonr

Biblioteka: scipy.stats.pearsonr(x, y) (zwraca wspÃ³Å‚czynnik i p-wartoÅ›Ä‡)

Test 7: WspÃ³Å‚czynnik Korelacji rang Spearmana

Kiedy: Gdy co najmniej jedna ze zmiennych NIE ma rozkÅ‚adu normalnego. Jest to test nieparametryczny.

Hipoteza (H0): Nie ma monotonicznej korelacji miÄ™dzy zmiennymi.

Klucz implementacji: spearmanr

Biblioteka: scipy.stats.spearmanr(x, y) (zwraca wspÃ³Å‚czynnik i p-wartoÅ›Ä‡)

Scenariusz 4: 2 Zmienne Kategoryczne (PrzykÅ‚ad: Sprawdzenie relacji miÄ™dzy 'PÅ‚ciÄ…' a 'Poziomem WyksztaÅ‚cenia')

Test 8: Test Chi-kwadrat (Ï‡Â²) NiezaleÅ¼noÅ›ci

Kiedy: Zawsze dla dwÃ³ch zmiennych kategorycznych (choÄ‡ wymaga pewnych zaÅ‚oÅ¼eÅ„ co do wielkoÅ›ci oczekiwanych w komÃ³rkach).

Hipoteza (H0): Zmienne sÄ… od siebie niezaleÅ¼ne (nie ma miÄ™dzy nimi zwiÄ…zku).

Klucz implementacji: chi2

Biblioteka: Wymaga stworzenia tabeli kontyngencji (pd.crosstab(kat1, kat2)), a nastÄ™pnie scipy.stats.chi2_contingency(tabela).

Test 9: DokÅ‚adny test Fishera (Fisher's Exact Test)

Kiedy: Gdy zaÅ‚oÅ¼enia do testu Chi-kwadrat nie sÄ… speÅ‚nione (np. w tabeli 2x2 sÄ… komÃ³rki z wartoÅ›ciÄ… oczekiwanÄ… < 5). Jest to dobra alternatywa dla maÅ‚ych prÃ³bek.

Hipoteza (H0): Zmienne sÄ… od siebie niezaleÅ¼ne.

Klucz implementacji: fisher_exact

Biblioteka: scipy.stats.fisher_exact(tabela_2x2)

III. Testy dla Danych Sparowanych (Rozszerzenie)
SÄ… to kluczowe testy, ale wymagajÄ… innej logiki wyboru (np. wybrania 2 kolumn numerycznych i zaznaczenia "sÄ… to dane sparowane").

Scenariusz 5: 2 Zmienne Numeryczne (Sparowane) (PrzykÅ‚ad: PorÃ³wnanie 'Wynik PRZED' (Num 1) z 'Wynik PO' (Num 2))

Test 10: Test t dla prÃ³b zaleÅ¼nych (Paired T-test)

Kiedy: Gdy RÃ“Å»NICE miÄ™dzy parami majÄ… rozkÅ‚ad normalny.

Hipoteza (H0): Åšrednia rÃ³Å¼nica miÄ™dzy parami wynosi zero.

Klucz implementacji: ttest_rel

Biblioteka: scipy.stats.ttest_rel(data_przed, data_po)

Test 11: Test rang Wilcoxona (Wilcoxon Signed-Rank Test)

Kiedy: Gdy RÃ“Å»NICE miÄ™dzy parami NIE majÄ… rozkÅ‚adu normalnego. Test nieparametryczny.

Hipoteza (H0): Mediana rÃ³Å¼nic miÄ™dzy parami wynosi zero.

Klucz implementacji: wilcoxon

Biblioteka: scipy.stats.wilcoxon(data_przed, data_po)